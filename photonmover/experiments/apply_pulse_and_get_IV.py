# Applies pulses of specified duration and amplitude (with the HP
# pulse generator and electrical attenuator)
# and then measures the IV curve using a source meter

from photonmover.Interfaces.Experiment import Experiment
from photonmover.utils.plot_utils import plot_graph
from photonmover.experiments.iv_curve import IVCurve

# Interfaces/instruments necessary for the experiment
# - You use an Interface if any instrument of that category can be used
# - You use a specific instrument if you can only use that specific model
from photonmover.Interfaces.ElectricalAttenuator import ElectricalAttenuator
from photonmover.Interfaces.SourceMeter import SourceMeter
from photonmover.instruments.Pattern_generators.HP70843B import HP70843B

# This is only necessary for the example
from photonmover.instruments.Electrical_attenuators.HP11713A import HP11713A
from photonmover.instruments.Source_meters.Keithley2400 import Keithley2400

# General imports
import time
import numpy as np


class apply_pulse_and_get_IV(Experiment):

    def __init__(self, instrument_list, visa_lock=None):
        """
        :param instrument_list: list of available instruments. IMPORTANT:
        WE ASSUME THAT THE INSTRUMENTS HAVE BEEN INITIALIZED ALREADY!
        """
        super().__init__(visa_lock)

        # It is always good practice to initialize variables in the init

        # Instruments
        self.el_att = None
        self.smu = None
        self.patt_gen = None

        self.data = None

        if not self.check_necessary_instruments(instrument_list):
            raise ValueError(
                "The instruments for this experiment are not present!")

    def check_necessary_instruments(self, instrument_list):
        """
        Checks if the instruments to perform the experiment are present.
        :param instrument_list: list of the available instruments
        :return: True if the instruments are present, False otherwise.
        """

        for instr in instrument_list:
            if isinstance(instr, SourceMeter):
                self.smu = instr
            if isinstance(instr, ElectricalAttenuator):
                self.el_att = instr
            if isinstance(instr, HP70843B):
                self.patt_gen = instr

        return (
            self.smu is not None
            and self.el_att is not None
            and self.patt_gen is not None
        )

    def get_description(self):
        """
        Returns a string with a brief summary of the experiment.
        """
        return " Applies pulses of a given duration and amplitude and " \
               " then acquires an IV curve. "

    def get_name(self):
        """
        Returns a string with the experiment name
        """
        return "Apply pulse and meas IV"

    def perform_experiment(self, params, filename=None):
        """
        Performs the experiment, and saves the relevant data (if there is any)
        to the specified file (if given)
        :param params: dict of the parameters necessary for the experiment.
        :param filename: if specified, the data is saved in the specified file.
        :return:
        """

        params = self.check_all_params(params)

        # List of voltages at which we want to get the IV curve
        iv_biases = params["iv_voltages"]
        # List of durations for each of the pulses (in s)
        pulse_durations = params["pulse_durations"]
        pulse_amps = params["pulse_amps"]  # List of pulse amplitudes (in V)
        # How long should we apply the pulse train (in s)
        puls_appl_t = params["pulse_appl_t"]
        # This is the amplitude of the pulse generated by the setup with 0 dB
        # attenuation
        puls_amp_0dB_att = params["pulse_amp_0dB_att"]

        # For each combination of pulse amplitude and pulse duration,
        # apply pulses for the specified duration and
        # then get an IV curve

        for pulse_amp in pulse_amps:

            self.patt_gen.turn_off()
            # Set the correct pulse amplitude. We modulate the pulse amplitude
            # by controlling the attenuation of the electrical attenuator.

            if pulse_amp > puls_amp_0dB_att:
                print(
                    'The specified amplitude is not achievable with this'
                    'setup! Doing max amplitude')
                self.el_att.set_attenuation(0)
                real_pulse_amp = puls_amp_0dB_att
            else:
                v_att = -10 * np.log10(pulse_amp / puls_amp_0dB_att)
                power_att = 2 * v_att
                # Round to the nearest whole dB number
                power_att = round(power_att)
                self.el_att.set_attenuation(power_att)
                real_pulse_amp = puls_amp_0dB_att * \
                        np.power(10, -power_att / 20)

            for pulse_duration in pulse_durations:

                # Configure the pattern generator to generate the desired
                # pulses
                self.patt_gen.configure_pulse(
                    repetition_rate=35e6,
                    pulse_width=pulse_duration,
                    amplitude=0.9,
                    hilevel=0.9,
                    polarity='positive')  # Hardcoded values!

                self.patt_gen.turn_on()
                input()
                time.sleep(puls_appl_t)
                self.patt_gen.turn_off()

                # The pulses have been applied. Now get the IV curve

                iv_acq = IVCurve([self.smu])
                n_filename = '%s--pulse_total_time=%.2fs--pulse_width=%.2es--pulse_amp=%.2fV' % (
                    filename, puls_appl_t, pulse_duration, real_pulse_amp)
                iv_data = iv_acq.perform_experiment(
                    params={"voltages": iv_biases}, filename=n_filename)
                self.data = iv_data

                print(
                    'Done amp = %.2fV; duration = %.2es' %
                    (real_pulse_amp, pulse_duration))

        return iv_data

    def required_params(self):
        """
        Returns a list with the keys that need to be specified
        in the params dictionary, in order for
        a measurement to be performed
        """
        return [
            "iv_voltages",
            "pulse_durations",
            "pulse_amps",
            "pulse_appl_t",
            "pulse_amp_0dB_att"]

    def plot_data(self, canvas_handle, data=None):

        if data is None:
            if self.data is not None:
                data = self.data
            else:
                raise ValueError(
                    'plot_data was called before performing the experiment'
                    'or providing data')

        volts = data[:, 0]
        curs = data[:, 1]

        plot_graph(
            x_data=volts,
            y_data=np.log10(
                np.abs(curs)),
            canvas_handle=canvas_handle,
            xlabel='Voltage (V)',
            ylabel='log10(Current) (A)',
            title='IV curve',
            legend=None)


if __name__ == '__main__':

    # INSTRUMENTS
    smu = Keithley2400()
    patt_gen = HP70843B()
    el_att = HP11713A()

    smu.initialize()
    patt_gen.initialize()
    el_att.initialize()

    # EXPERIMENT PARAMETERS
    # iv_volts = np.linspace(1, -1, 201)
    # p_widths = [100e-12, 200e-12, 300e-12, 400e-12, 500e-12, \
    #  600e-12, 700e-12, 800e-12, 900e-12, 1000e-12]
    # p_amps = [0.1, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6]
    # p_app_t = 1
    # p_amp_0dB = 6.0
    iv_volts = np.linspace(-0.05, 0.05, 51)
    p_widths = [100e-12]
    p_amps = [0.5]
    p_app_t = 1
    p_amp_0dB = 3.0

    base_file_name = './data/nanowire_phase_change'

    # SET UP THE EXPERIMENT
    instr_list = [smu, patt_gen, el_att]
    exp = apply_pulse_and_get_IV(instr_list)
    params = {
        "iv_voltages": iv_volts,
        "pulse_durations": p_widths,
        "pulse_amps": p_amps,
        "pulse_appl_t": p_app_t,
        "pulse_amp_0dB_att": p_amp_0dB}

    # RUN IT
    exp.perform_experiment(params, filename=base_file_name)

    # CLOSE INSTRUMENTS
    smu.close()
    patt_gen.close()
    el_att.close()
